function p = initTrialStructure(p)
%
% p = initTrialStructure(p)
% 
% Define the trial types for a single "block" of trials.

% --- 1. Define column descriptions ---
% This needs to match the columns generated by our recipe table functions.
p.init.trialArrayColumnNames = {'halfBlock', 'targetLocIdx', ...
    'stimType', 'salience', 'reward', 'targetColor', 'numTrials', ...
    'trialCode'};

% --- 2. Get the recipe table based on the experiment type ---
switch p.init.exptType
        
    case 'gSac_4factors'
        % This is our new experiment type
        table = fourFactorsTable;
        
    otherwise
        error('p.init.exptType is not valid');
end          

% --- 3. Expand the recipe table into the final trialsArray ---
% This generic expansion logic remains untouched and works for any recipe table.
nCols = length(p.init.trialArrayColumnNames);
p.init.trialsArray = zeros(sum(table(:, nCols - 1)), nCols);
currentRow = 1;

% loop over each row of the table.
for i = 1:size(table, 1)
    % how many repetitions of the current row do we need?
    nReps = table(i, contains(p.init.trialArrayColumnNames, 'numTrials'));
    
    if nReps > 0
        % place the repeated row into the "trials" array
        p.init.trialsArray(currentRow:(currentRow + nReps - 1), :) = ...
            repmat(table(i, :), nReps, 1);

        % update the currentRow variable
        currentRow = currentRow + nReps;
    end
end

% --- 4. Shuffle trials within each block ---
% This ensures trial order is randomized but blocks are respected.
nTrials = size(p.init.trialsArray, 1);
nBlocks = p.init.trialsArray(end, 1) / 2; % Assumes 2 half-blocks per block
nTrialsPerBlock = nTrials / nBlocks;

shuffledArray = [];
for i_block = 1:nBlocks
    block_start_row = (i_block - 1) * nTrialsPerBlock + 1;
    block_end_row = i_block * nTrialsPerBlock;
    
    current_block_trials = p.init.trialsArray(block_start_row:block_end_row, :);
    
    % shuffle the rows of the current block
    shuffled_block = current_block_trials(randperm(size(current_block_trials, 1)), :);
    
    % append to the master shuffled array
    shuffledArray = [shuffledArray; shuffled_block];
end

p.init.trialsArray = shuffledArray;

% --- 5. Add a column to indicate which rows have been completed ---
p.init.trialsArray(:, end+1) = 0;
p.init.trialArrayColumnNames{end+1} = 'completed';

% Create a logical array to draw trials from
p.status.trialsArrayRowsPossible = true(size(p.init.trialsArray, 1), 1);
end

function table = fourFactorsTable
% fourFactorsTable
%
% Generates the master "recipe" table for the REDESIGNED experiment.
% This version creates a trial structure with 6 distinct stimulus conditions.

%% 1. Define Column Names (for reference)
% {'halfBlock', 'targetLocIdx', 'stimType', 'salience', 'reward', ...
%  'targetColor', 'numTrials', 'trialCode'};

%% 2. Define the 6 Stimulus Conditions and their mapping to the columns
% We define a mapping that translates our 6 conceptual conditions into the
% values that will be stored in the 'stimType', 'salience', and 'targetColor' columns.

% stimType | salience | targetColor
% 1: Face      | 0        | 0
% 2: Non-Face  | 0        | 0
% 3: HS, TC1   | 1        | 1
% 4: LS, TC1   | 2        | 1
% 5: HS, TC2   | 1        | 2
% 6: LS, TC2   | 2        | 2
stim_condition_map = [ ...
    1, 0, 0; ...
    2, 0, 0; ...
    3, 1, 1; ...
    4, 2, 1; ...
    5, 1, 2; ...
    6, 2, 2; ...
    ];

n_stim_conditions = size(stim_condition_map, 1);
n_half_blocks = 4; % 2 blocks total
n_locations = 4;

% Pre-allocate the master recipe table.
% 4 half-blocks * 4 locations * 6 stim conditions
table = zeros(n_half_blocks * n_locations * n_stim_conditions, 8);


%% 3. Build the Recipe Table row by row
current_row = 1;
for i_half_block = 1:n_half_blocks
    
    % Determine the high-probability location for this block
    block_num = ceil(i_half_block / 2);
    if block_num == 1
        high_prob_loc = 1;
    else % block_num == 2
        high_prob_loc = 3;
    end
    
    % Determine if it's the first or second half of a block (for reward)
    is_first_half_of_block = mod(i_half_block, 2) == 1;
    
    for i_loc = 1:n_locations
        for i_stim = 1:n_stim_conditions
            
            % --- Get stimulus properties from our map ---
            stimType    = stim_condition_map(i_stim, 1);
            salience    = stim_condition_map(i_stim, 2);
            targetColor = stim_condition_map(i_stim, 3);
            
            % --- Populate columns for this condition ---
            table(current_row, 1) = i_half_block;
            table(current_row, 2) = i_loc;
            table(current_row, 3) = stimType;
            table(current_row, 4) = salience;
            table(current_row, 6) = targetColor;
            
            % --- Set numTrials based on location probability ---
            % 10 reps for high-prob (split as 5 per half-block)
            % 2 reps for low-prob (split as 1 per half-block)
            if i_loc == high_prob_loc
                table(current_row, 7) = 5; % numTrials
            else
                table(current_row, 7) = 1; % numTrials
            end
            
            % --- Set Reward based on hemifield and half-block ---
            is_loc_in_high_rwd_hemi = (i_loc <= 2);
            if (is_first_half_of_block && is_loc_in_high_rwd_hemi) || ...
               (~is_first_half_of_block && ~is_loc_in_high_rwd_hemi)
                table(current_row, 5) = 1; % High Reward
            else
                table(current_row, 5) = 2; % Low Reward
            end
            
            % --- Generate a unique trial code ---
            % We will use a simple counter for the condition code (1-24)
            condition_code = (i_loc - 1) * n_stim_conditions + i_stim;
            table(current_row, 8) = 26000 + (block_num * 1000) + condition_code;
                
            current_row = current_row + 1;
        end
    end
end
end