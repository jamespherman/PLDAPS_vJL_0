function p = gSac_4factors_run(p)
%
% This version contains the final updates to the stateMachine and drawMachine
% to be consistent with the new static CLUT design.
%
%%
% (1) mark start time.
[p.trData.timing.trialStartPTB, p.trData.timing.trialStartDP] = ...
    pds.getTimes;
%% (2) while-loop
while ~p.trVars.exitWhileLoop
    
    % iterate while-loop counter
    p.trVars.whileLoopIdx = p.trVars.whileLoopIdx + 1;
    
    % Update eye / joystick & Mouse position:
    p = pds.getEyeJoy(p);
    p = pds.getMouse(p);
    if p.trVars.mouseEyeSim == 1
        p.trVars.eyePixX   = p.trVars.mouseCursorX - p.draw.middleXY(1);
        p.trVars.eyePixY   = p.trVars.mouseCursorY - p.draw.middleXY(2);
        p.trVars.eyeDegX   = pds.pix2deg(p.trVars.eyePixX, p);
        p.trVars.eyeDegY   = pds.pix2deg(-p.trVars.eyePixY, p);
    end
    
    % store just-sampled gaze position and calculate eye velocity
    p = onlineGazeCalcs(p);
    
    % STATE DEPENDENT section
    p = stateMachine(p);
    
    % TIME-DEPENDENT section
    p = timingMachine(p);
    
    % DRAW:
    p = drawMachine(p);
     
end % while loop
end
%% ---------------------
function p = stateMachine(p)
% p = stateMachine(p)
timeNow = GetSecs - p.trData.timing.trialStartPTB;
switch p.trVars.currentState
    case p.state.trialBegun
        p.init.strb.addValue(p.init.codes.trialBegin);
        p.trData.timing.trialBegin      = timeNow;
        p.trVars.currentState        = p.state.waitForJoy;
        
    case p.state.waitForJoy
        if pds.joyHeld(p)
            p.init.strb.addValue(p.init.codes.joyPress);
            p.trData.timing.joyPress    = timeNow;
            p.trVars.currentState    = p.state.showFix;
        elseif ~pds.joyHeld(p) && (timeNow > p.trVars.joyWaitDur)
            p.trVars.currentState    = p.state.nonStart;
        end
        
    case p.state.showFix
        p.draw.color.fix    = p.draw.clutIdx.expBlack_subBlack; % User changed this to black, but settings file says white
        p.draw.color.fixWin = p.draw.clutIdx.expGrey70_subBg;
        p.draw.fixWinPenDraw = p.draw.fixWinPenThin;
        
        p.init.strb.addValueOnce(p.init.codes.fixOn);
        if p.trData.timing.fixOn < 0
            p.trData.timing.fixOn = timeNow;
        end
        
        if pds.eyeInWindow(p) && pds.joyHeld(p) && timeNow < (p.trData.timing.fixOn + p.trVars.fixWaitDur)
            p.init.strb.addValue(p.init.codes.fixAq);
            p.trData.timing.fixAq      = timeNow;
            p.trVars.currentState      = p.state.dontMove;
        elseif ~pds.joyHeld(p)
            p.init.strb.addValue(p.init.codes.joyRelease);
            p.trData.timing.joyRelease = timeNow;
            p.trVars.currentState      = p.state.joyBreak;
        elseif timeNow > (p.trData.timing.fixOn + p.trVars.fixWaitDur)
            p.init.strb.addValue(p.init.codes.nonStart);
            p.trData.timing.joyRelease = timeNow;
            p.trVars.currentState      = p.state.nonStart;
        end
        
    case p.state.dontMove
        %%% --- UPDATED SECTION --- %%%
        % Set target window color for experimenter using the correct clutIdx name
        p.draw.color.targWin = p.draw.clutIdx.expGrey70_subBg;
        %%% --- END UPDATED SECTION --- %%%
        
        p.draw.fixWinPenDraw = p.draw.fixWinPenThick;
        
        if (timeNow - p.trData.timing.fixAq) > p.trVars.timeFixOffset
            p.init.strb.addValue(p.init.codes.fixOff);
            p.trData.timing.fixOff    = timeNow;
            p.trVars.currentState     = p.state.makeSaccade;
        elseif ~pds.eyeInWindow(p)
            p.init.strb.addValue(p.init.codes.fixBreak);
            p.trData.timing.fixBreak    = timeNow;
            p.trVars.currentState       = p.state.fixBreak;
        elseif ~pds.joyHeld(p)
            p.init.strb.addValue(p.init.codes.joyRelease);
            p.trData.timing.joyRelease  = timeNow;
            p.trVars.currentState       = p.state.joyBreak;
        end
        
    case p.state.makeSaccade
        p.draw.color.fix = p.draw.color.background;
        if ~pds.joyHeld(p)
            p.init.strb.addValue(p.init.codes.joyRelease);
            p.trData.timing.joyRelease  = timeNow;
            p.trVars.currentState       = p.state.joyBreak;
        end
        if ~pds.eyeInWindow(p) && timeNow < (p.trData.timing.fixOff + p.trVars.goLatencyMin)
            p.init.strb.addValue(p.init.codes.fixBreak);
            p.trData.timing.fixBreak    = timeNow;
            p.trVars.currentState       = p.state.fixBreak;
        elseif (~pds.eyeInWindow(p) && timeNow > (p.trData.timing.fixOff + p.trVars.goLatencyMin) && timeNow < (p.trData.timing.fixOff + p.trVars.goLatencyMax) && gazeVelThreshCheck(p, timeNow)) || p.trVars.passEye
            p.init.strb.addValue(p.init.codes.saccadeOnset);
            p.trData.timing.saccadeOnset    = timeNow;
            p.trVars.currentState           = p.state.checkLanding;
            p.draw.fixWinPenDraw = p.draw.fixWinPenThin;
            disp('saccadeMade')
        elseif timeNow > (p.trData.timing.fixOff + p.trVars.goLatencyMax)
            p.init.strb.addValue(p.init.codes.fixBreak);
            p.trData.timing.fixBreak    = timeNow;
            p.trVars.currentState       = p.state.fixBreak;
            disp('fixBreak')
        end
      case p.state.checkLanding
        if ~pds.joyHeld(p), p.init.strb.addValue(p.init.codes.joyRelease); p.trData.timing.joyRelease  = timeNow; p.trVars.currentState = p.state.joyBreak; end
        sacInFlight = gazeVelThreshCheck(p, timeNow);
        sinceFixOffLogical = p.trData.onlineGaze(:,3) > p.trData.timing.fixOff & p.trData.onlineGaze(:,3) < timeNow;
        blinkDetected = any(any(abs(p.trData.onlineGaze(sinceFixOffLogical, 1:2)) > 35));
        gazeInTargetWin = pds.eyeInWindow(p, 'target');
        if sacInFlight, elseif blinkDetected, disp('blink detected'); p.init.strb.addValue(p.init.codes.blinkDuringSac); p.trData.timing.fixBreak = timeNow; p.trVars.currentState = p.state.fixBreak;
        elseif gazeInTargetWin || p.trVars.passEye, p.init.strb.addValue(p.init.codes.saccadeOffset); p.trData.timing.saccadeOffset = timeNow; p.trVars.currentState = p.state.holdTarg; p.init.strb.addValue(p.init.codes.targetAq); p.trData.timing.targetAq = timeNow; p.draw.targWinPenDraw = p.draw.targWinPenThick;
        elseif ~gazeInTargetWin || ~p.trVars.passEye, p.init.strb.addValue(p.init.codes.fixBreak); p.trData.timing.fixBreak = timeNow; p.trVars.currentState = p.state.fixBreak; p.draw.targWinPenDraw = p.draw.targWinPenThin; end
      case p.state.holdTarg
        if ~pds.joyHeld(p), p.init.strb.addValue(p.init.codes.joyRelease); p.trData.timing.joyRelease  = timeNow; p.trVars.currentState = p.state.joyBreak; end
        eyeInTargetWin = pds.eyeInWindow(p, 'target');
        if eyeInTargetWin && timeNow > p.trData.timing.saccadeOffset + p.trVars.targHoldDuration, p.trVars.currentState = p.state.sacComplete; p.draw.targWinPenDraw = p.draw.targWinPenThick;
        elseif ~eyeInTargetWin, p.init.strb.addValue(p.init.codes.fixBreak); p.trData.timing.fixBreak = timeNow; p.trVars.currentState = p.state.fixBreak; p.draw.targWinPenDraw = p.draw.targWinPenThin; disp('target break'); end
    case p.state.sacComplete
        if p.trData.timing.reward < 0, p = pds.deliverReward(p);
        elseif p.trData.timing.reward > 0 && (timeNow - p.trData.timing.reward) > (p.trVars.postRewardDuration + p.rig.dp.dacPadDur + p.trVars.rewardDurationMs/1000), p.trVars.exitWhileLoop = true; end
    case p.state.fixBreak
        p = playTone(p, 'low'); p.trVars.exitWhileLoop = true;
    case p.state.joyBreak
        p = playTone(p, 'low'); p.trVars.exitWhileLoop = true;
    case p.state.nonStart
        p = playTone(p, 'low'); p.trVars.exitWhileLoop = true;
end
if p.trVars.exitWhileLoop
    p.draw.color.fix = p.draw.color.background;
    p.draw.color.fixWin = p.draw.color.background;
    p.draw.fixWinPenDraw = p.draw.fixWinPenThin;
    p.draw.targWinPenDraw = p.draw.targWinPenThin;
    p.trData.trialEndState = p.trVars.currentState;
end
end
%%
function p = drawMachine(p)
timeNow = GetSecs - p.trData.timing.trialStartPTB;

%%% --- UPDATED SECTION --- %%%
%% 1. Set Dynamic Background Color for this Trial
% Based on the 6-level stimType, set the background to the correct CLUT index.
switch p.trVars.stimType
    case {1, 2} % Face or Non-Face Image Trial
        p.draw.color.background = p.draw.clutIdx.expGrey_subBg;
    case 3 % Bullseye: High Salience, Target 0 deg
        p.draw.color.background = p.draw.clutIdx.expDkl180_subDkl180;
    case 4 % Bullseye: Low Salience, Target 0 deg
        p.draw.color.background = p.draw.clutIdx.expDkl45_subDkl45;
    case 5 % Bullseye: High Salience, Target 180 deg
        p.draw.color.background = p.draw.clutIdx.expDkl0_subDkl0;
    case 6 % Bullseye: Low Salience, Target 180 deg
        p.draw.color.background = p.draw.clutIdx.expDkl225_subDkl225;
end
%%% --- END UPDATED SECTION --- %%%

%% 2. Drawing (if it's time for the next frame)
if timeNow > p.trData.timing.lastFrameTime + p.rig.frameDuration - p.rig.magicNumber
    
    Screen('FillRect', p.draw.window, p.draw.color.background);
    Screen('DrawLines', p.draw.window, p.draw.gridXY, [], p.draw.color.gridMajor);
    Screen('FillRect', p.draw.window, p.draw.color.eyePos, [p.trVars.eyePixX p.trVars.eyePixY p.trVars.eyePixX p.trVars.eyePixY] + [-1 -1 1 1]*p.draw.eyePosWidth + repmat(p.draw.middleXY, 1, 2));
    Screen('FrameRect',p.draw.window, p.draw.color.targWin, repmat(p.draw.targPointPix, 1, 2) +  [-p.draw.targWinWidthPix -p.draw.targWinHeightPix p.draw.targWinWidthPix p.draw.targWinHeightPix], p.draw.targWinPenDraw);
    Screen('FrameRect',p.draw.window, p.draw.color.fixWin, repmat(p.draw.fixPointPix, 1, 2) +  [-p.draw.fixWinWidthPix -p.draw.fixWinHeightPix p.draw.fixWinWidthPix p.draw.fixWinHeightPix], p.draw.fixWinPenDraw);
    
    if p.trVars.reward == 1
        Screen('FrameRect',p.draw.window, p.draw.clutIdx.expGreen_subBg, repmat(p.draw.targPointPix, 1, 2) + fix(1.1 * [-p.draw.targWinWidthPix -p.draw.targWinHeightPix p.draw.targWinWidthPix p.draw.targWinHeightPix]), p.draw.targWinPenDraw);
    end
    
    if p.trVars.targetIsOn
        if p.trVars.stimType <= 2 % It's an Image Trial
            stimSize_pix = pds.deg2pix(p.stim.stimDiamDeg, p);
            targRect = CenterRectOnPoint([0 0 stimSize_pix stimSize_pix], p.draw.targPointPix(1), p.draw.targPointPix(2));
            try
            Screen('DrawTexture', p.draw.window, p.stim.currentTexture, [], targRect);
            catch me
                keyboard
            end
        else % It's a Bullseye Trial
            if p.trVars.stimType <= 4 % Type A target (0 deg)
                target_hue_idx = p.draw.clutIdx.expDkl0_subDkl0;
            else % Type B target (180 deg)
                target_hue_idx = p.draw.clutIdx.expDkl180_subDkl180;
            end
            
            % Draw two concentric rectangular rings for the bullseye
            % Outer ring at 4 degrees
            stimSize_pix_outer = pds.deg2pix(4, p);
            targRect_outer = CenterRectOnPoint([0 0 stimSize_pix_outer stimSize_pix_outer], p.draw.targPointPix(1), p.draw.targPointPix(2));
            Screen('FrameRect', p.draw.window, target_hue_idx, targRect_outer, p.trVarsInit.targWidth);
            
            % Inner ring at 2 degrees
            stimSize_pix_inner = pds.deg2pix(2, p);
            targRect_inner = CenterRectOnPoint([0 0 stimSize_pix_inner stimSize_pix_inner], p.draw.targPointPix(1), p.draw.targPointPix(2));
            Screen('FrameRect', p.draw.window, target_hue_idx, targRect_inner, p.trVarsInit.targWidth);
        end
    end
    
    Screen('FrameRect',p.draw.window, p.draw.color.fix, repmat(p.draw.fixPointPix, 1, 2) + p.draw.fixPointRadius*[-1 -1 1 1], p.draw.fixPointWidth);
    
    [p.trData.timing.flipTime(p.trVars.flipIdx)] = Screen('Flip', p.draw.window, GetSecs + 0.00);
    p.trData.timing.lastFrameTime = p.trData.timing.flipTime(p.trVars.flipIdx) - p.trData.timing.trialStartPTB;
    p.trVars.flipIdx = p.trVars.flipIdx + 1;
end
end
%%
function p = onlineGazeCalcs(p)
p.trData.onlineGaze(p.trVars.whileLoopIdx, :) = [p.trVars.eyeDegX, p.trVars.eyeDegY, GetSecs - p.trData.timing.trialStartPTB, NaN];
if p.trVars.whileLoopIdx > p.trVarsInit.eyeVelFiltTaps
    tempDiff = diff(p.trData.onlineGaze((p.trVars.whileLoopIdx - p.trVarsInit.eyeVelFiltTaps + 1):p.trVars.whileLoopIdx, 1:3));
    p.trData.onlineGaze(p.trVars.whileLoopIdx, 4) = sqrt(sum(mean((tempDiff(:, 1:2) ./ repmat(tempDiff(:, 3), 1, 2)).^2)));
end
end
%%
function logOut = gazeVelThreshCheck(p, timeNow)
logOut = (p.trData.onlineGaze(p.trVars.whileLoopIdx, 4) > p.trVars.eyeVelThresh);
end
function p = timingMachine(p)
timeNow = GetSecs - p.trData.timing.trialStartPTB;
p.trData.timing.frameNow    = fix(timeNow * p.rig.refreshRate);
if p.trData.timing.fixAq > 0
    timeFromFixAq = timeNow - p.trData.timing.fixAq;
    if timeFromFixAq >= p.trVars.timeTargOnset && timeFromFixAq < p.trVars.timeTargOffset && p.trData.timing.targetOn < 0
        p.trVars.targetIsOn       = true;
        p.init.strb.addValueOnce(p.init.codes.targetOn);
        p.trData.timing.targetOn = timeNow;
    elseif ~p.trVars.isVisSac && (p.trVars.currentState == p.state.holdTarg || (p.trData.timing.fixOff > 0 && p.trVars.targTrainingDelay >= 0 && timeNow > (p.trData.timing.fixOff + p.trVars.targTrainingDelay)))
        p.trVars.targetIsOn       = true;
        if p.trData.timing.targetReillum < 0
            p.init.strb.addValueOnce(p.init.codes.targetReillum);
            p.trData.timing.targetReillum = timeNow;
        end
    elseif ~(timeFromFixAq < p.trVars.timeTargOffset)
        p.trVars.targetIsOn       = false;
        p.init.strb.addValueOnce(p.init.codes.targetOff);
        if p.trData.timing.targetOff < 0 && p.trData.timing.targetOn > 0
            p.trData.timing.targetOff = timeNow;
        end
    end
end
end