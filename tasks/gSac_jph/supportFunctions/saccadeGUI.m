function uiData = saccadeGUI(varargin)

% make "uiData" object.
uiData = makeUiData;

% store the initial list of target locations (tiling the area).
uiData          = initTargetLocs(uiData);

% build UI elements
uiData          = buildUiElements(uiData);

% if an argument is supplied, it determined whether the gui is being
% debugged or not; otherwise assume the gui isn't being debugged.
if nargin > 0
    debugMode = varargin{1};
else
    debugMode = true;
end

% If gui is being debugged, generate some data.
if debugMode
    uiData     = genDummySacData(uiData);
else
    % if gui isn't being debugged, try to pull some data from the main
    % PLDAPS gui; first get it's handle:
    uiData.handles.pldapsGui = findall(0, 'Name', 'PLDAPS_vK2_GUI');
    
    % get PLDAPS data
    uiData.pldapsData = guidata(uiData.handles.pldapsGui);
end

% monitor "sacDataArray" for changes and update plots accordingly
addlistener(uiData, 'sacDataArray', 'PostSet', ...
    @(i1,i2)updatePlots(i1, i2, uiData));

% monitor "spikesAndEvents" for changes and update plots accordingly
addlistener(uiData, 'spikesAndEvents', 'PostSet', ...
    @(i1,i2)updatePlots(i1, i2, uiData));

% run an initial "update" of plots
updatePlots([], [], uiData);

% update 'UserData' field with populated data structure.
set(uiData.handles.hGui, 'UserData', uiData);

% set(hMainFigure, 'Position', [2561        1441        1600        1178]);
%set(hMainFigure, 'Position', [57           5        1287         720]);

end

%%%% Define callback functions
function hPlotAxes_ButtonDownFcn(hObject, eventdata, GUIfig)
% This function is used to grab user-input. A user clicks on this graph if
% they want to add points to the list of saccade targets. That list is
% stored in one field of the 'UserData' field of the GUI figure. This is
% why we have the 'GUIfig' argument to this function, so we can easily pass
% the figure handle.

% Grab data structure
uiData                          = get(GUIfig, 'UserData');

% grab last-clicked point
clickedPt                           = get(hObject, 'CurrentPoint');

% update list of targets: (1) find not-yet-completed targets, (2) increment
% their "order", (3) add the new point, placing it first in the "order".
uiData.sacDataArray             = [...
    [clickedPt(1,1:2), NaN(1, 6), false]; uiData.sacDataArray];

% update data structure
set(GUIfig, 'UserData', uiData);
end

function HeatMapProps_Callback(hObject, eventdata, uiData)

% return a list of the panel's children so we have all the values we need.
pKids = get(uiData.handles.hHMPanel, 'Children');

% make a list of the tags for each of the uicontrols, we can use this to
% retreive the values of the controls.
editTags = {'DivPerDeg', 'XLow', 'XHigh', 'YLow', 'YHigh'};

% grab the values (note: I like this one-liner!)
vals = cellfun(@(x)str2double(get(pKids(arrayfun(@(y)strcmp(get(y,'Tag'), x), pKids)), 'String')), editTags)';

% delete old heatmap, contour, and color bar objects.
delete([uiData.handles.hHeatMap, uiData.handles.hCntr, uiData.handles.hColrBar])

% build new EMPTY ones
hTemp = buildHeatMap(vals(2:3)', vals(4:5)', vals(1), uiData.handles.hPlotAx, uiData.handles.hColBrAx);
uiData.handles.hHeatMap    = hTemp(1);
uiData.handles.hCntr    = hTemp(2);
uiData.handles.hColrBar = hTemp(3);

% set axis limits
set(uiData.handles.hPlotAx, 'XLim', vals(2:3)', 'YLim', vals(4:5)');

% reconstruct
updateHeatMap(uiData)
end

function figSave_callback(hObject, eventdata, uiData)

fileNameBox = uiData.handles.hFigFileNameBox;
fileName    = [uiData.pldapsData.paths.pldapsDir '/output/', ...
    get(fileNameBox, 'String'), '.mat'];

disp('Saving Figure file...')
hgsave(uiData.handles.hGui, fileName)
disp('HeatMap Figure Saved!')
end

function dataSave_callback(hObject, eventdata, uiData)

fileNameBox = uiData.handles.hMatFileNameBox;
fileName    = [uiData.pldapsData.paths.pldapsDir '/output/', ...
    get(fileNameBox, 'String'), '.mat'];

sacData = uiData.sacDataArray;
mapData = uiData.heatMaps;
disp('Saving .MAT file...')
save(fileName, 'sacData', 'mapData');
disp('MAT file Saved!')
end

function colorSelect_callback(hObject, eventdata, uiData)

% get colormap selction listbox strings and values
colorMapStrings = get(hObject, 'String');
colorMapValue   = get(hObject, 'Value');

% define colormap array
newColorMap     = eval([colorMapStrings{colorMapValue} '(64);']);

% apply new colormap to figure
set(uiData.handles.hGui, 'Colormap', newColorMap);

end

function hTargetLoc_ButtonDownFcn(hObject, eventdata, uiData)

% get the X & Y location of the clicked point
ptXYs   = cell2mat(get(hObject, {'XData', 'YData'}));

% index the row of "sacDataArray" corresponding to this target
% location.
whichPt = all(bsxfun(@eq, uiData.sacDataArray(:,1:2), ptXYs), 2);

% If this is an "empty" (unvisited) target location, delete it, the
% associated saccade endpoint indicator and connecting line, and get rid of
% the associated row of "sacDataArray".
if all(get(hObject, 'MarkerFaceColor') == [1 1 1])
    
    % mark object for deletion
    set(hObject, 'Tag', 'ToDelete');
    
    % get rid of the appropriate row of "sacDataArray"
    uiData.sacDataArray(whichPt, :) = [];
else
    % get rid of the saccade data for the appropriate row of "sacDataArray"
    uiData.sacDataArray(whichPt, 3:9) = [NaN(1, 6), false];
end

end

function mapLoad_callback(hObject, eventdata, uiData)

% temporary variable name for the filename display object handle
fnobj = uiData.handles.hFileNameDisp;

% prompt the user to select a file
[f, p] = uigetfile('*.mat');

% make sure the user hasn't cancelled
if f ~=0
    
    % iterate the load counter
    set(hObject, 'UserData', get(hObject, 'UserData') + 1);
    
    % set the filename text object to display the filename of the selected
    % file.
    set(fnobj, 'String', f(1:find(f=='.', 1, 'first')-1));
    
    % load data.
    temp = load([p,f]);
    data = temp.data;
    
    % how many columns do we have?
    nCols = size(data, 2);
    
    % let user label data; make a small figure with UI elements to this
    % purpose.
    tempHandles.loadFig = figure(...
        'MenuBar', 'none', ...
        'Toolbar', 'none', ...
        'HandleVisibility', 'callback', ...
        'Name', 'data label GUI', ...
        'NumberTitle', 'off', ...
        'Color', [1 1 1], ...
        'Position', [0 0 300 500], ...
        'NextPlot', 'Add');
    
    % define list of default data variables
    defaultVars = {'X', 'Y', 'pkv', 'srt', 'other'};
    
    % make ui elements for each column
    for i = 1:nCols
        
        % make one "row" of ui elements for each column; first figure out
        % the vertical position for the current row.
        vPos = 0.85 - (i - 1)*0.15;
        
        % define default value for popupmenus
        defPopVal = min([i, length(defaultVars)]);
        
        % make text label
        tempHandles.colText(i)  = uicontrol(...
            'Parent', tempHandles.loadFig, ...
            'Style', 'text', ...
            'String', ['column ' num2str(i) ':'], ...
            'FontSize', 14, ...
            'Units', 'Normalized', ...
            'BackGroundColor', [1 1 1], ...
            'Position', [0.01 vPos 0.275 0.1]);
        
        % make popupmenu to select variable type; set 'Tag' property to 'i'
        % so that we can make the corresponding edit box visible if the
        % user selects "other".
        tempHandles.colMenu(i)  = uicontrol(...
            'Parent', tempHandles.loadFig, ...
            'Style', 'popupmenu', ...
            'String', defaultVars, ...
            'Value', defPopVal, ...
            'FontSize', 14, ...
            'Units', 'Normalized', ...
            'BackGroundColor', [1 1 1], ...
            'Position', [0.32 vPos 0.275 0.1], ...
            'Tag', num2str(i));
        
        % make text field for user to enter custom data, start with this
        % invisible by default.
        tempHandles.colEdit(i)  = uicontrol(...
            'Parent', tempHandles.loadFig, ...
            'Style', 'edit', ...
            'String', 'varName', ...
            'Value', defPopVal, ...
            'FontSize', 14, ...
            'Units', 'Normalized', ...
            'BackGroundColor', [1 1 1], ...
            'Position', [0.62 vPos 0.325 0.1], ...
            'Visible', 'Off');
        
    end
    
    % make text field for user to enter custom data, start with this
    % invisible by default.
    tempHandles.doneButton  = uicontrol(...
        'Parent', tempHandles.loadFig, ...
        'Style', 'togglebutton', ...
        'String', 'done', ...
        'FontSize', 14, ...
        'Units', 'Normalized', ...
        'BackGroundColor', [1 1 1], ...
        'Position', [0.01 0.01 0.98 0.1]);
    
    % define callback for popupmenu ui elements
    set(tempHandles.colMenu, 'Callback', ...
        {@varNameSelect_callback, tempHandles})
    
    % wait for user to close data naming window
    while get(tempHandles.doneButton, 'Value') < 1
        drawnow;
    end
    
    % need to count how many variables are being loaded (other than X & Y),
    % we'll make a new map for each.
    nMapVars = 0;
    
    % collect data to build new map(s); loop over columns and determine
    % which contain X & Y (saccade endpoint) values, and which contain
    % "map" values.
    for i = 1:nCols
        
        % if something other than "other" is selected in the popupmenu, the
        % variable name is the selected entry, otherwise, check the string
        % in the corresponding edit box. Retreive strings and values to
        % determine what entry is selected.
        menuStrings = get(tempHandles.colMenu(i), 'String');
        menuVal     = get(tempHandles.colMenu(i), 'value');
        
        % what's selected
        switch menuStrings{menuVal}
            case 'X'
                X = data(:, i);
            case 'Y'
                Y = data(:, i);
            case 'pkv'
                nMapVars                = nMapVars + 1;
                mapVarNames{nMapVars}   = 'pkv';
                mapVarCols(nMapVars)    = i;
            case 'srt'
                nMapVars                = nMapVars + 1;
                mapVarNames{nMapVars}   = 'srt';
                mapVarCols(nMapVars)    = i;
            case 'other'
                nMapVars                = nMapVars + 1;
                mapVarNames{nMapVars}   = ...
                    get(tempHandles.colEdit(i), 'String');
                mapVarCols(nMapVars)    = i;
        end
    end
    
    % close temp ui fig
    close(tempHandles.loadFig)
    
    % loop over map values to build maps
    for i = 1:nMapVars
        
        % how many files have been loaded?
        loadCount = get(hObject, 'UserData');
        
        % make a name for the new map
        mapNameString = [mapVarNames{i} 'Load' num2str(loadCount)];
        
        
        % make new heatmap
        uiData = makeNewHeatMap(uiData, X, Y, ...
            data(:, mapVarCols(i)), mapNameString);
    end
    
    % reassign uiData
    set(uiData.handles.hGui, 'UserData', uiData);
end

end

function varNameSelect_callback(hObject, eventData, tempHandles)

% get popupmenu strings, current value, and 'Tag'
menuStrings = get(hObject, 'String');
menuVal     = get(hObject, 'value');
menuTag     = str2double(get(hObject, 'Tag'));

% if the user has selected "other", make the corresponding edit box
% visible, if not, make it visible just in case the user selected "other"
% and then switched to something else.
if strcmp('other', menuStrings(menuVal))
    set(tempHandles.colEdit(menuTag), 'Visible', 'On');
else
    set(tempHandles.colEdit(menuTag), 'Visible', 'Off');
end

end

function mapSelect_callback(hObject, eventdata, uiData)

% if the user single-clicked, just update the heatmap based on what has
% been selected, otherwise, open a new figure with the heatmap plotted.
if ~strcmp(get(uiData.handles.hGui, 'SelectionType'), 'open')
    updateHeatMapDisplay(uiData);
else
    popOutHeatMap(uiData)
end

end

function spikeMapType_callback(hObject, eventData, uiData)

% if the user has changed the event that spikes should be aligned to for
% counting, or the window for counting, this function is called. If the
% user changed the alignment event, just update the map, but if they
% modified the counting window, we need to check that the values they input
% are okay (e.g. numeric); if the values are not okay we need to correct
% them.

switch eventData.Source.Tag
    case 'hSpikeMapType'

        % the source of this callback is the 'pulldown' menu in the
        % spikeMapType panel, just update the heatmap, in that update
        % function we'll make use of the parameters defined in the
        % spikeMapType panel to define the map:
        updateHeatMap(uiData);

    otherwise

        % the source of this callback is one of the 'edit' uicontrols in
        % the spikeMapType panel; try to convert the text string from that
        % edit uicontrol to a numeric:
        newVal = str2double(hObject.String);

        % if a valid numeric has been input, update the 'Value' property of
        % the uicontrol, then update the heatmap. Otherwise, just reset the
        % string in the uicontrol based on the existing value property:
        if ~isempty(newVal)
            hObject.Value = newVal;
            updateHeatMap(uiData);
        else
            hObject.String = num2str(hObject.Value);
        end
end

end

%%%% Define other functions

function popOutHeatMap(uiData)

% if this isn't the first popout, add it to the list of popout fig handles,
% otherwise create the fieldname in "uiData.handles"
if isfield(uiData.handles, 'popOutFig')
    uiData.handles.popOutFig(end + 1) = figure(...
        'MenuBar', 'none', ...
        'Toolbar', 'none', ...
        'HandleVisibility', 'callback', ...
        'NumberTitle', 'off', ...
        'Color', [1 1 1], ...
        'Position', [0 0 1000 800], ...
        'NextPlot', 'Add');
else
    uiData.handles.popOutFig(1) = figure(...
        'MenuBar', 'none', ...
        'Toolbar', 'none', ...
        'HandleVisibility', 'callback', ...
        'NumberTitle', 'off', ...
        'Color', [1 1 1], ...
        'Position', [0 0 1000 800], ...
        'NextPlot', 'Add');
end

% copy axes to new figure
newAx = copyobj(uiData.handles.hPlotAxes, uiData.handles.popOutFig(end));

% make axes take up whole figure
set(newAx, 'Position', [0.05 0.05 0.9 0.9]);

% delete saccade indicators
delete(findobj(get(newAx, 'Children'), 'Type', 'line'));


end

function uiData = buildUiElements(uiData)

% GUI figure
uiData.handles.hGui =   figure(...              % the main GUI figure
    'MenuBar', 'none', ...
    'Toolbar', 'none', ...
    'HandleVisibility', 'callback', ...
    'Name', 'saccade mapping GUI', ...
    'NumberTitle', 'off', ...
    'Color', [1 1 1], ...
    'Position', [0 0 1000 1066], ...
    'NextPlot', 'Add', ...
    'Colormap', hot(64));

uiData.handles.hPlotAxes   =   axes(...         % HeatMap plot axes
    'Tag', 'hPlotAxes', ...
    'Parent', uiData.handles.hGui, ...
    'Units', 'normalized', ...
    'HandleVisibility', 'callback', ...
    'Position', [0.0375 0.325 0.6 0.65], ...
    'CLim', [0 1], ...
    'CLimMode', 'manual', ...
    'FontSize', 14, ...
    'TickDir', 'Out', ...
    'TickLength', [0.005 0.025], ...
    'LineWIdth', 1, ...
    'NextPlot', 'Add', ...
    'ButtonDownFcn', {@hPlotAxes_ButtonDownFcn, uiData.handles.hGui});

uiData.handles.hColorBarAxes       =   axes(...  % HeatMap colorbar axes
    'Tag', 'hColorBarAxes', ...
    'Parent', uiData.handles.hGui, ...
    'Units', 'normalized', ...
    'HandleVisibility', 'callback', ...
    'Position', [0.6562 0.325 0.02625 0.65], ...
    'CLim', [0 1], ...
    'CLimMode', 'manual', ...
    'FontSize', 14, ...
    'TickDir', 'Out', ...
    'TickLength', [0.005 0.025], ...
    'LineWIdth', 1, ...
    'NextPlot', 'Add', ...
    'XTickLabel', [], ...
    'YAxisLocation', 'right');

% an empty heatmap with default degree limits / divisions-per-degree
hmXLims     = [-30, 30];
hmYLims     = [-20, 20];
divPerDeg   = 0.5;
uiData      = buildHeatMap(uiData, [hmXLims, hmYLims, divPerDeg]);

% make spike plotting axes:
uiData          = makeSpikePlotAxes(uiData);

% make a gui-panel for controlling what heatmap is displayed
uiData          = makeHeatMapSelectionPanel(uiData);

% make a gui-panel for controlling heatmap color scheme
uiData          = makeColormapSelectionPanel(uiData);

% make a gui-panel to store controls selecting the target location
% uiData          = makeTargetSelectPanel(uiData);

% make a gui-panel to store controls for saving the figure
uiData          = makeFigureSavePanel(uiData);

% make a gui-panel for specifying how the next target location is chosen
uiData          = makeTargetSelectPanel(uiData);

% make a gui-panel to store controls for selecting which spike data should
% be used to build a spikes-based heatmap:
uiData          = makeSpikeMapSelectionPanel(uiData);

% make a gui-panel to store controls for loading a pre-existing peak
% heatmap
uiData          = makeLoadPanel(uiData);

% target locations plot objects. first create an "unvisited target
% location" plot object. We'll hold on to this so that if/when the user
% adds new target locations, they retain the "unvisited" appearance. Also
% create a saccade endpoint graphics object for each target location, and a
% connecting line for them.

nPts                               = size(uiData.sacDataArray, 1);
uiData.handles.hTargetLocUnvis     = plot(uiData.handles.hPlotAxes, ...
    NaN, NaN, 'ko', ...
    'LineWidth', 2, ...
    'MarkerSize', 12, ...
    'HitTest', 'On', ...
    'ButtonDownFcn', {@hTargetLoc_ButtonDownFcn, uiData});
uiData.handles.hSacEndLoc          = plot(uiData.handles.hPlotAxes, ...
    NaN, NaN, 'ks', ...
    'LineWidth', 2, ...
    'HitTest','off');
uiData.handles.hTargSacConLine     = plot(uiData.handles.hPlotAxes, ...
    NaN(1,2), NaN(1,2), 'k', ...
    'HitTest', 'off');
uiData.handles.hTargetLocs         = copyobj(...
    uiData.handles.hTargetLocUnvis, ...
    repmat(uiData.handles.hPlotAxes, nPts, 1));
uiData.handles.hSacEndLocs         = copyobj(...
    uiData.handles.hSacEndLoc, ...
    repmat(uiData.handles.hPlotAxes, nPts, 1));
uiData.handles.hTargSacConLines    = copyobj(...
    uiData.handles.hTargSacConLine, ...
    repmat(uiData.handles.hPlotAxes, nPts, 1));
set(uiData.handles.hTargetLocs, 'ButtonDownFcn', ...
    {@hTargetLoc_ButtonDownFcn, uiData});
end

function uiData = buildHeatMap(uiData, defProps)

hmXLims     = defProps(1:2);
hmYLims     = defProps(3:4);
divPerDeg   = defProps(5);

% define number sampling points for heatmap based on desired range and
% divisions per degree.
nXDiv                   = round(range(hmXLims)/divPerDeg) + 1;
nYDiv                   = round(range(hmYLims)/divPerDeg) + 1;

% make heatmap object
uiData.handles.hHeatMap = pcolor(uiData.handles.hPlotAxes, ...
    linspace(hmXLims(1),hmXLims(2), nXDiv), ...
    linspace(hmYLims(1),hmYLims(2),nYDiv), NaN(nYDiv,nXDiv));

% turn off warning about non-finite data
warning('off','MATLAB:contour:NonFiniteData')

% make contour object
[~, uiData.handles.hContour]   = contour(uiData.handles.hPlotAxes, ...
    linspace(hmXLims(1),hmXLims(2), nXDiv), ...
    linspace(hmYLims(1),hmYLims(2),nYDiv), ...
    NaN(nYDiv,nXDiv), 'LineWidth', 1.5, 'LineColor', [1 1 1]);

% make color bar object
uiData.handles.hColorBarIm     = pcolor(uiData.handles.hColorBarAxes, ...
    [0,1], linspace(0,1,100), NaN(100,2));

% don't let users click on heatmap objects (only the axes underneath).
set(uiData.handles.hHeatMap, 'HitTest', 'off', 'EdgeColor', 'none');
set(uiData.handles.hContour, 'HitTest', 'off');
set(uiData.handles.hColorBarIm, 'EdgeColor', 'none');
end

function uiData = makeSpikePlotAxes(uiData)

% spike RATE plotting axes - aligned to target onset
uiData.handles.hSpikeRateAxesTargetOnset   =   axes(...
    'Tag', 'hSpikeRateAxesTargetOnset', ...
    'Parent', uiData.handles.hGui, ...
    'Units', 'normalized', ...
    'Position', [0.732 0.795 0.24 0.18], ...
    'HandleVisibility', 'callback', ...
    'FontSize', 10, ...
    'TickDir', 'Out', ...
    'TickLength', [0.005 0.025], ...
    'LineWIdth', 1, ...
    'NextPlot', 'Add', ...
    'Color', 'None', ...
    'YColor', [1 0 0], ...
    'YAxisLocation', 'right', ...
    'XColor', 'None');

% spike RASTER plotting axes - aligned to target onset
uiData.handles.hSpikeRasterAxesTargetOnset   =   axes(...
    'Tag', 'hSpikeRasterAxesTargetOnset', ...
    'Parent', uiData.handles.hGui, ...
    'Units', 'normalized', ...
    'Position', uiData.handles.hSpikeRateAxesTargetOnset.Position, ...
    'HandleVisibility', 'callback', ...
    'FontSize', 10, ...
    'TickDir', 'Out', ...
    'TickLength', [0.005 0.025], ...
    'LineWIdth', 1, ...
    'NextPlot', 'Add', ...
    'Color', 'None');
uiData.handles.hSpikeRasterAxesTargetOnset.XLabel.String = ...
    'Target Onset Time (s)';

% spike RATE plotting axes - aligned to fixation offset
uiData.handles.hSpikeRateAxesFixOffset   =   axes(...
    'Tag', 'hSpikeRateAxesFixOffset', ...
    'Parent', uiData.handles.hGui, ...
    'Units', 'normalized', ...
    'Position', [0.732 0.57 0.24 0.18], ...
    'HandleVisibility', 'callback', ...
    'FontSize', 10, ...
    'TickDir', 'Out', ...
    'TickLength', [0.005 0.025], ...
    'LineWIdth', 1, ...
    'NextPlot', 'Add', ...
    'Color', 'None', ...
    'YColor', [1 0 0], ...
    'YAxisLocation', 'right', ...
    'XColor', 'None');

% spike RASTER plotting axes - aligned to fixation offset
uiData.handles.hSpikeRasterAxesFixOffset   =   axes(...
    'Tag', 'hSpikeRasterAxesTargetOnset', ...
    'Parent', uiData.handles.hGui, ...
    'Units', 'normalized', ...
    'Position', uiData.handles.hSpikeRateAxesFixOffset.Position, ...
    'HandleVisibility', 'callback', ...
    'FontSize', 10, ...
    'TickDir', 'Out', ...
    'TickLength', [0.005 0.025], ...
    'LineWIdth', 1, ...
    'NextPlot', 'Add', ...
    'Color', 'None');
uiData.handles.hSpikeRasterAxesFixOffset.XLabel.String = ...
    'Fixation Offset Time (s)';

% spike raster plotting axes - aligned to saccade onset
uiData.handles.hSpikeRateAxesSaccadeOnset   =   axes(...
    'Tag', 'hSpikeRateAxesSaccadeOnset', ...
    'Parent', uiData.handles.hGui, ...
    'Units', 'normalized', ...
    'Position', [0.732 0.345 0.24 0.18], ...
    'HandleVisibility', 'callback', ...
    'FontSize', 10, ...
    'TickDir', 'Out', ...
    'TickLength', [0.005 0.025], ...
    'LineWIdth', 1, ...
    'NextPlot', 'Add', ...
    'Color', 'None', ...
    'YColor', [1 0 0], ...
    'YAxisLocation', 'right', ...
    'XColor', 'None');

% spike raster plotting axes - aligned to saccade onset
uiData.handles.hSpikeRasterAxesSaccadeOnset   =   axes(...
    'Tag', 'hSpikeRasterAxesSaccadeOnset', ...
    'Parent', uiData.handles.hGui, ...
    'Units', 'normalized', ...
    'Position', uiData.handles.hSpikeRateAxesSaccadeOnset.Position, ...
    'HandleVisibility', 'callback', ...
    'FontSize', 10, ...
    'TickDir', 'Out', ...
    'TickLength', [0.005 0.025], ...
    'LineWIdth', 1, ...
    'NextPlot', 'Add', ...
    'Color', 'None');
uiData.handles.hSpikeRasterAxesSaccadeOnset.XLabel.String = ...
    'Saccade Onset Time (s)';

% A "raster line" plot object. We make one of these now then make copies of
% it as needed when actual spike time values come in.
uiData.handles.hRasterLine = plot(...
    uiData.handles.hSpikeRateAxesTargetOnset, ...
    NaN(2,1), ...
    NaN(2,1), ...
    'Color',0.6*[1 1 1], ...
    'LineWidth',1);

% Plot objects for plotting spike rate traces.
uiData.handles.hSpikeRateTargetOnset = plot(...
    uiData.handles.hSpikeRateAxesTargetOnset, ...
    NaN, ...
    NaN, ...
    'b', ...
    'LineWidth', 1);
uiData.handles.hSpikeRateFixOffset = plot(...
    uiData.handles.hSpikeRateAxesFixOffset, ...
    NaN, ...
    NaN, ...
    'b', ...
    'LineWidth', 1);
uiData.handles.hSpikeRateSaccadeOnset = plot(...
    uiData.handles.hSpikeRateAxesSaccadeOnset, ...
    NaN, ...
    NaN, ...
    'b', ...
    'LineWidth', 1);

% Plot objects marking 0 in each of the three spike axes:
uiData.handles.hSpikeZeroMarkTargetOnset = plot(...
    uiData.handles.hSpikeRasterAxesTargetOnset, ...
    [0 0], [0 1], '-', 'Color', 0.3*[1 1 1], 'LineWidth', 1);
uiData.handles.hSpikeZeroMarkFixOffset = plot(...
    uiData.handles.hSpikeRasterAxesFixOffset, ...
    [0 0], [0 1], '-', 'Color', 0.3*[1 1 1], 'LineWidth', 1);
uiData.handles.hSpikeZeroMarkSaccadeOnset = plot(...
    uiData.handles.hSpikeRasterAxesSaccadeOnset, ...
    [0 0], [0 1], '-', 'Color', 0.3*[1 1 1], 'LineWidth', 1);

end

function uiData = makeHeatMapSelectionPanel(uiData)
% make a uipanel to contain the controls for the appearance of the heatmap
uiData.handles.hHeatMapSelectionPanel  = uipanel(...
    'Tag', 'hHeatMapSelectionPanel', ...
    'Parent', uiData.handles.hGui, ...
    'Title','heatMap selection', ...
    'TitlePosition', 'centertop', ...
    'FontSize', 12,...
    'ForeGroundColor', [0 0 0.6], ...
    'BackGroundColor', [1 1 1], ...
    'ShadowColor', [0 0 1], ...
    'Position', [0.0075 0.01 0.15 0.275]);

uiData.handles.hHeatMapSelectionList    = uicontrol(...
    'Tag', 'hHeatMapSelectionList', ...
    'Parent', uiData.handles.hHeatMapSelectionPanel, ...
    'Units','normalized',...
    'Style', 'listbox', ...
    'Position', [0.0075 0.01 0.7350 0.98], ...
    'ForeGroundColor', [0 0 0.6], ...
    'FontSize', 32, ...
    'Max', 2, ...
    'Min', 0, ...
    'Callback', {@mapSelect_callback, uiData});

end

function uiData = makeColormapSelectionPanel(uiData)
% make a uipanel to contain the controls for the appearance of the heatmap
uiData.handles.hColorMapSelectionPanel  = uipanel(...
    'Tag', 'hColorMapSelectionPanel', ...
    'Parent', uiData.handles.hGui, ...
    'Title','heatMap colors', ...
    'TitlePosition', 'centertop', ...
    'FontSize', 12,...
    'ForeGroundColor', [0 0 0.6], ...
    'BackGroundColor', [1 1 1], ...
    'ShadowColor', [0 0 1], ...
    'Position', [0.3225 0.01 0.09375 0.275]);

% make a uicontrol to allow the user to select a color scheme
colorMapStrings = {'jet', 'hsv', 'hot', 'cool', 'spring', 'summer', ...
    'autumn', 'winter', 'gray', 'bone', 'copper', 'pink'};
uiData.handles.hColorMapSelectionList    = uicontrol(...
    'Tag', 'hColorMapSelectionList', ...
    'Parent', uiData.handles.hColorMapSelectionPanel, ...
    'Units','normalized',...
    'Style', 'listbox', ...
    'Position', [0.01 0.01 0.735 0.98], ...
    'ForeGroundColor', [0 0 0.6], ...
    'FontSize', 16, ...
    'String', colorMapStrings', ...
    'Value', 3, ...
    'Callback', {@colorSelect_callback, uiData});

end

function uiData = makeTargetSelectPanel(uiData)
% make a uipanel to contain the controls for the appearance of the heatmap
uiData.handles.hTSelectPanel       = uipanel(...
    'Tag', 'uiData.handles.hTSelectPanel', ...
    'Parent', uiData.handles.hGui, ...
    'Title','next target location selection', ...
    'TitlePosition', 'centertop', ...
    'FontSize',12,...
    'ForeGroundColor', [0 0 0.6], ...
    'ShadowColor', [0 0 1], ...
    'BackGroundColor', [1 1 1], ...
    'Position',[0.4237 0.01 0.15 0.275]);

uiData.handles.hRadioGrp1          = uibuttongroup(...
    'Parent', uiData.handles.hTSelectPanel, ...
    'Tag', 'uiData.handles.hRadioGrp1', ...
    'Units','normalized',...
    'Position', [0.025 0.525 0.4 0.4]);

uiData.handles.hRandomTgtButton       =   uicontrol(...
    'Tag', 'hRandomTgtButton', ...
    'Parent', uiData.handles.hRadioGrp1, ...
    'Units','normalized',...
    'Position',[0.025 0.55 0.95 0.5],...
    'Style','radiobutton',...
    'String', 'random');

uiData.handles.hSpecTgtButton       =   uicontrol(...
    'Tag', 'hSpecTgtButton', ...
    'Parent', uiData.handles.hRadioGrp1, ...
    'Units','normalized',...
    'Position',[0.025 0.05 0.95 0.5],...
    'Style','radiobutton',...
    'String', 'specified');

uiData.handles.hXText              = uicontrol(...
    'Tag', 'hXText', ...
    'Parent', uiData.handles.hTSelectPanel, ...
    'Units', 'Normalized', ...
    'Style', 'text', ...
    'String', 'X:', ...
    'FontSize', 26, ...
    'HorizontalAlignment', 'Right', ...
    'BackGroundColor', [1 1 1], ...
    'Position', [0.44 0.59 0.2 0.2]);

uiData.handles.hYText              = uicontrol(...
    'Tag', 'hYText', ...
    'Parent', uiData.handles.hTSelectPanel, ...
    'Units', 'Normalized', ...
    'Style', 'text', ...
    'String', 'Y:', ...
    'FontSize', 26, ...
    'HorizontalAlignment', 'Right', ...
    'BackGroundColor', [1 1 1], ...
    'Position', [0.44 0.14 0.2 0.2]);

uiData.handles.hXVal               = uicontrol(...
    'Tag', 'hXVal', ...
    'Parent', uiData.handles.hTSelectPanel, ...
    'Units', 'Normalized', ...
    'Style', 'edit', ...
    'String', '0', ...
    'FontSize', 26, ...
    'Position', [0.65 0.62 0.3 0.2]);

uiData.handles.hYVal              = uicontrol(...
    'Tag', 'hYVal', ...
    'Parent', uiData.handles.hTSelectPanel, ...
    'Units', 'Normalized', ...
    'Style', 'edit', ...
    'String', '0', ...
    'FontSize', 26, ...
    'Position', [0.65 0.18 0.3 0.2]);

end

function uiData = makeFigureSavePanel(uiData)

uiData.handles.hSavePanel       = uipanel(...
    'Tag','hSavePanel', ...
    'Parent', uiData.handles.hGui, ...
    'Units', 'Normalized', ...
    'Title','save figure / data', ...
    'TitlePosition', 'centertop', ...
    'FontSize',12,...
    'ForeGroundColor', [0 0.6 0], ...
    'ShadowColor', [0 1 0], ...
    'BackGroundColor', [1 1 1], ...
    'Position',[0.5813 0.01 0.18 0.275]);

uiData.handles.hFigFileName       = uicontrol(...
    'Tag','hFigFileName', ...
    'Parent', uiData.handles.hSavePanel, ...
    'Style', 'text', ...
    'FontSize', 12, ...
    'FontWeight', 'bold', ...
    'Units', 'Normalized', ...
    'BackGroundColor', [1 1 1], ...
    'Position', [0.01 0.875 0.98 0.1], ...
    'String', 'Figure File Name:', ...
    'HorizontalAlignment', 'Left');

uiData.handles.hFigFileNameBox        = uicontrol(...
    'Tag','hFileNameBox', ...
    'Parent', uiData.handles.hSavePanel, ...
    'Style', 'edit', ...
    'String', ['heatMapFig_' datestr(now, 'yyyymmdd') '_'], ...
    'FontSize', 12, ...
    'Units', 'Normalized', ...
    'BackGroundColor', [1 1 1], ...
    'Position', [0.01 0.7 0.98 0.15]);

% Make figure save button; store a logical variable in the userdata of this
% object indicating whether it's been used or not. If it hasn't, when the
% figure is closed, autosave the figure.
uiData.handles.hFigureSaveButton   = uicontrol(...
    'Tag','hFigureSaveButton', ...
    'Parent', uiData.handles.hSavePanel, ...
    'Style', 'pushbutton', ...
    'String', 'Save Figure', ...
    'FontSize', 12, ...
    'FontWeight', 'bold', ...
    'Units', 'Normalized', ...
    'Position', [0.01 0.525 0.98 0.125], ...
    'BackGroundColor', [1 1 1], ...
    'Callback', {@figSave_callback, uiData}, ...
    'UserData', false);

uiData.handles.hMatFileName       = uicontrol(...
    'Tag','hMatFileName', ...
    'Parent', uiData.handles.hSavePanel, ...
    'Style', 'text', ...
    'FontSize', 12, ...
    'FontWeight', 'bold', ...
    'Units', 'Normalized', ...
    'BackGroundColor', [1 1 1], ...
    'Position', [0.01 0.375 0.98 0.1], ...
    'String', '.MAT File Name:', ...
    'HorizontalAlignment', 'Left');

uiData.handles.hMatFileNameBox        = uicontrol(...
    'Tag','hMatFileNameBox', ...
    'Parent', uiData.handles.hSavePanel, ...
    'Style', 'edit', ...
    'String', ['heatMapData_' datestr(now, 'yyyymmdd') '_'], ...
    'FontSize', 12, ...
    'Units', 'Normalized', ...
    'Tag', 'FileName', ...
    'BackGroundColor', [1 1 1], ...
    'Position', [0.01 0.2 0.98 0.15]);

uiData.handles.hDataSaveButton   = uicontrol(...
    'Tag','hDataSaveButton', ...
    'Parent', uiData.handles.hSavePanel, ...
    'Style', 'pushbutton', ...
    'String', 'Save Data .MAT', ...
    'FontSize', 12, ...
    'FontWeight', 'bold', ...
    'Units', 'Normalized', ...
    'Position', [0.01 0.025 0.98 0.125], ...
    'BackGroundColor', [1 1 1], ...
    'Callback', {@dataSave_callback, uiData});
end

function uiData = makeSpikeMapSelectionPanel(uiData)

% Make a panel to hold gui elements for determining which spike data will
% be used to construct a spike count-based heatmap. We need gui elements
% for:
% (1) Selecting which event we want to align the spikes to (by default this
% will be target onset, but should also include saccade onset and fixation
% offset).
% (2) Selecting the time window (relative to the alignment event) in which
% we want to count spikes.

uiData.handles.hSpikeMapPanel     = uipanel(...
    'Tag','hSpikeMapPanel', ...
    'Parent', uiData.handles.hGui, ...
    'Units', 'Normalized', ...
    'Title','choose spike map data source', ...
    'TitlePosition', 'centertop', ...
    'FontSize',12,...
    'ForeGroundColor', [0 0.6 0], ...
    'ShadowColor', [0 1 0], ...
    'BackGroundColor', [1 1 1], ...
    'Position',[0.77 0.01 0.2 0.275]);

uiData.handles.hSpikeMapTypeLabel   = uicontrol(...
    'Tag','hSpikeMapTypeLabel', ...
    'Parent', uiData.handles.hSpikeMapPanel, ...
    'Style', 'text', ...
    'FontSize', 12, ...
    'FontWeight', 'bold', ...
    'Units', 'Normalized', ...
    'BackGroundColor', [1 1 1], ...
    'Position', [0.02 0.825 0.96 0.1], ...
    'String', 'Align spike count window to:', ...
    'HorizontalAlignment', 'Left');

uiData.handles.hSpikeMapType       = uicontrol(...
    'Tag','hSpikeMapType', ...
    'Parent', uiData.handles.hSpikeMapPanel, ...
    'Style', 'popupmenu', ...
    'FontSize', 12, ...
    'Units', 'Normalized', ...
    'BackGroundColor', [1 1 1], ...
    'Position', [0.01 0.65 0.98 0.2], ...
    'Value', 1, ...
    'String', {'targetOnset', 'fixationOffset', 'saccadeOnset'}, ...
    'HorizontalAlignment', 'Center', ...
    'Callback', {@spikeMapType_callback, uiData});

uiData.handles.hSpikeCountWinStartLabel   = uicontrol(...
    'Tag','hSpikeCountWinStartLabel', ...
    'Parent', uiData.handles.hSpikeMapPanel, ...
    'Style', 'text', ...
    'FontSize', 12, ...
    'FontWeight', 'bold', ...
    'Units', 'Normalized', ...
    'BackGroundColor', [1 1 1], ...
    'Position', [0.02 0.5 0.44 0.2], ...
    'String', 'Start of count window (ms):', ...
    'HorizontalAlignment', 'Left');

uiData.handles.hSpikeCountWinStart        = uicontrol(...
    'Tag','hSpikeCountWinStart', ...
    'Parent', uiData.handles.hSpikeMapPanel, ...
    'Style', 'edit', ...
    'Value', 50, ...
    'String', '50', ...
    'FontSize', 12, ...
    'Units', 'Normalized', ...
    'BackGroundColor', [1 1 1], ...
    'Position', [0.02 0.35 0.44 0.2], ...
    'Callback', {@spikeMapType_callback, uiData});

uiData.handles.hSpikeCountWinEndLabel   = uicontrol(...
    'Tag','hSpikeCountWinEndLabel', ...
    'Parent', uiData.handles.hSpikeMapPanel, ...
    'Style', 'text', ...
    'FontSize', 12, ...
    'FontWeight', 'bold', ...
    'Units', 'Normalized', ...
    'BackGroundColor', [1 1 1], ...
    'Position', [0.52 0.5 0.44 0.2], ...
    'String', 'End of count window (ms):', ...
    'HorizontalAlignment', 'Left');

uiData.handles.hSpikeCountWinEnd        = uicontrol(...
    'Tag','hSpikeCountWinEnd', ...
    'Parent', uiData.handles.hSpikeMapPanel, ...
    'Style', 'edit', ...
    'Value', 200, ...
    'String', '200', ...
    'FontSize', 12, ...
    'Units', 'Normalized', ...
    'BackGroundColor', [1 1 1], ...
    'Position', [0.52 0.35 0.44 0.2], ...
    'Callback', {@spikeMapType_callback, uiData});

end

function uiData = makeLoadPanel(uiData)

uiData.handles.hLoadPanel       = uipanel(...
    'Tag', 'hLoadPanel', ...
    'Parent', uiData.handles.hGui, ...
    'Units', 'Normalized', ...
    'Title','load map data', ...
    'TitlePosition', 'centertop', ...
    'FontSize',12,...
    'ForeGroundColor', [0 0.6 0.6], ...
    'BackGroundColor', [1 1 1], ...
    'ShadowColor', [0 1 1], ...
    'Position', [0.1650 0.01 0.15 0.275]);

uiData.handles.hFileNameText       = uicontrol(...
    'Tag', 'hFileNameText', ...
    'Parent', uiData.handles.hLoadPanel, ...
    'Style', 'text', ...
    'String', 'Last file:', ...
    'FontSize', 14, ...
    'FontWeight', 'bold', ...
    'BackGroundColor', [1 1 1], ...
    'Units', 'Normalized', ...
    'Position', [0.025 0.65 0.4 0.1]);

uiData.handles.hFileNameDisp        = uicontrol(...
    'Tag', 'hFileNameDisp', ...
    'Parent', uiData.handles.hLoadPanel, ...
    'Style', 'text', ...
    'String', 'no data loaded', ...
    'FontSize', 14, ...
    'Units', 'Normalized', ...
    'Tag', 'FileName', ...
    'BackGroundColor', [1 1 1], ...
    'Position', [0.025 0.475 0.8 0.15]);

% make load button; store a count of how many files have been loaded in the
% button's 'UserData' field.
uiData.handles.hLoadDataButton   = uicontrol(...
    'Tag', 'hFigureSaveButton', ...
    'Parent', uiData.handles.hLoadPanel, ...
    'Style', 'pushbutton', ...
    'String', 'Load', ...
    'FontSize', 14, ...
    'FontWeight', 'bold', ...
    'Units', 'Normalized', ...
    'Position', [0.025 0.025 0.95 0.25], ...
    'Callback', {@mapLoad_callback, uiData}, ...
    'UserData', 0);
end

function uiData = makeUiData

% define "uiData" as an object of class "simpleClass" (dynamic properties)
uiData              = SimpleClass;

% add properties to uiData
dsProps(1)          = addprop(uiData, 'sacDataArray');
dsProps(2)          = addprop(uiData, 'handles');
dsProps(3)          = addprop(uiData, 'heatMaps');
dsProps(4)          = addprop(uiData, 'pldapsData');
dsProps(5)          = addprop(uiData, 'spikesAndEvents');

% make "sacDataArray" and "spikesAndEvents" properties of "uiData"
% "observable" so that secondary GUI plots can be automatically updated
% when new data comes in:
dsProps(1).SetObservable = true;
dsProps(5).SetObservable = true;

end

function r = getRadius(theta, a, bX, bY)

% Choose radius to lie in a rectangular annulus with inner "radius" = a and
% outer radius = b, depending on angle. First step is calculating a
% "special case" angle because the annulus is rectangular.
spAng = atand(bY/bX);

% There are several cases for ranges of theta; I suspect there's a way to
% do this more cleanly / simply. Let's see what LNK has to say tomorrow!
if (theta > (360 - spAng) || theta <= spAng) || ...
        (theta > (180 - spAng) && theta <= (180 + spAng))
    r = abs((a./cosd(theta)) + ...
        rand*((bX./cosd(theta)) - (a./cosd(theta))));
elseif (theta > spAng && theta <= 45)
    r = abs((a./cosd(theta)) + ...
        rand*((bY./sind(theta)) - (a./cosd(theta))));
elseif (theta > 135 && theta <= (180 - spAng))
    r = abs(-(a./cosd(theta)) + ...
        rand*((bY./sind(theta)) + (a./cosd(theta))));
elseif (theta > (180 + spAng) && theta <= 225)
    r = abs(-(a./cosd(theta)) + ...
        rand*(-(bY./sind(theta)) + (a./cosd(theta))));
elseif (theta > 315 && theta <= (270 + spAng))
    r = abs((a./cosd(theta)) + ...
        rand*(-(bY./sind(theta)) - (a./cosd(theta))));
else
    r = abs((a./sind(theta)) + ...
        rand*((bY./sind(theta)) - (a./sind(theta))));
end

end

function uiData = genDummySacData(uiData)

% generate data for GUI testing
p = [0.0085 -0.4509 6.6532 9.9220 256.3290];
myFun = @(x)p(1)*x.^4 + p(2)*x.^3 + p(3)*x.^2 + p(4)*x + p(5) + ...
    randn(size(x)).*(x*4 + 25);

% how many "trials" of data to generate?
nTrials             = 75;

% loop over trials
for i = 1:nTrials
    
    % generate target location, saccade start & end points, peak velocity,
    % and reaction times
    targetTheta = 360*rand;
    targetRadius = getRadius(targetTheta, 2.5, 20, 15);
    
    targetX = targetRadius*cosd(targetTheta);
    targetY = targetRadius*sind(targetTheta);
    preSacXY   = [0, 0] + randn(1,2)/20;
    postSacXY  = [targetX, targetY] + randn(1,2);
    peakVel    = myFun(sum(postSacXY.^2)^0.5);
    SRT        = 0.25 + 0.05*randn;
    
    % store in uiData.sacDataArray
    uiData.sacDataArray(i, :) = [targetX, targetY, preSacXY, postSacXY, ...
        peakVel, SRT, true];
end

end

function uiData = initTargetLocs(uiData)

% number of initial x & y target locations
nXpts                       = 5;
nYpts                       = 5;

% X & Y limits
xMax    = 20;
yMax    = 12.5;

% define initial dimensions of "sacDataArray", n target locations rows by 9
% columns: (1) target X location, (2) target Y location, (3) pre-saccade
% gaze location X, (4) pre-saccade gaze location Y, (5) post-saccade gaze
% X, (6) post-saccade gaze Y, (7) peak velocity, (8) reaction time, (9) has
% this target location been used (logical)?
uiData.sacDataArray         = zeros(nXpts * nYpts, 9);

% define initial target locations
uiData.sacDataArray(:, 1:2) = sortrows(...
    [repmat(linspace(-xMax, xMax, nXpts)', nYpts, 1), ...
    reshape(repmat(linspace(-yMax, yMax, nYpts), nXpts, 1), ...
    nYpts*nXpts, 1)]);

% get rid of location at center
oPt                         = all(...
    bsxfun(@eq, uiData.sacDataArray(:, 1:2), [0 0]), 2);
uiData.sacDataArray(oPt,:)  = [];

% randomize order
uiData.sacDataArray  = uiData.sacDataArray(randperm(nYpts*nXpts - 1)', :);
end

function uiData = updatePlots(hObject, eventdata, uiData)

% update plots after new data comes in
updateTargetsPlot(uiData);
updateHeatMap(uiData);
updateSpikePlots(uiData);

end

function updateTargetsPlot(uiData)

% Three possibilities to deal with:
% (1) If the number of rows of "sacDataArray" is greater than the number of
% saccade target locations, we need to add a new saccade target location
% object.
% (2) If the number of rows of "sacDataArray" is smaller than the number of
% saccade target locations, we need to delete a saccade target location
% object (and associated saccade endpoint location and connecting line
% objects).
% (3) If the number of rows of "sacDataArray" is equal to the number of
% saccade target locations, we need to change the fill color of the target
% location object, the visibility of the saccade endpoint location
% and connecting line objects, and possibly the X & Y data for the endpoint
% / conecting line objects.

% Do we need to add a new plot object, delete a plot object or just change
% colors? 
% of plot objects to length of points-list.
nRows       = size(uiData.sacDataArray, 1);
nPlots      = size(uiData.handles.hTargetLocs,1);

% case (1)
if nRows > nPlots
    
    % make new plot objects 
    uiData.handles.hTargetLocs      = [...
        copyobj(uiData.handles.hTargetLocUnvis, ...
        repmat(get(uiData.handles.hTargetLocs(1,1), 'Parent'), ...
        nRows-nPlots, 1)); uiData.handles.hTargetLocs];
    uiData.handles.hSacEndLocs      = [...
        copyobj(uiData.handles.hSacEndLoc, ...
        repmat(get(uiData.handles.hSacEndLocs(1,1), 'Parent'), ...
        nRows-nPlots, 1)); uiData.handles.hSacEndLocs];
    uiData.handles.hTargSacConLines = [...
        copyobj(uiData.handles.hTargSacConLine, ...
        repmat(get(uiData.handles.hTargSacConLines(1,1), 'Parent'), ...
        nRows-nPlots, 1)); uiData.handles.hTargSacConLines];
elseif nRows < nPlots
    
    % find which object handle is tagged for deletion
    rowIdx = strcmp(get(uiData.handles.hTargetLocs, 'Tag'), 'ToDelete');
    
    % delete appropriate objects and get rid of their handles
    delete([uiData.handles.hTargetLocs(rowIdx); ...
        uiData.handles.hSacEndLocs(rowIdx); ...
        uiData.handles.hTargSacConLines(rowIdx)]);
    
    % get rid of handles
    uiData.handles.hTargetLocs(rowIdx)      = [];
    uiData.handles.hSacEndLocs(rowIdx)      = [];
    uiData.handles.hTargSacConLines(rowIdx) = [];
end

% position plot objects;
set(uiData.handles.hTargetLocs, ...
    {'XData'}, num2cell(uiData.sacDataArray(:, 1)), ...
    {'YData'}, num2cell(uiData.sacDataArray(:, 2)));

% fill in target locations that have been completed
doneGrp     = uiData.sacDataArray(:, 9) == 1;
if nnz(doneGrp)
    set(uiData.handles.hTargetLocs(doneGrp), ...
        {'MarkerFaceColor'}, mat2cell(zeros(sum(doneGrp), 3), ...
        ones(sum(doneGrp),1), 3));
    
    set(uiData.handles.hSacEndLocs(doneGrp), ...
        {'MarkerFaceColor'}, mat2cell(zeros(sum(doneGrp), 3), ...
        ones(sum(doneGrp),1), 3), ...
        {'XData'}, num2cell(uiData.sacDataArray(doneGrp, 5)), ...
        {'YData'}, num2cell(uiData.sacDataArray(doneGrp, 6)), ...
        'Visible', 'On');
    
    set(uiData.handles.hTargSacConLines(doneGrp), ...
        {'XData'}, mat2cell([uiData.sacDataArray(doneGrp, 1), ...
        uiData.sacDataArray(doneGrp, 5)], ones(nnz(doneGrp), 1), 2), ...
        {'YData'}, mat2cell([uiData.sacDataArray(doneGrp, 2), ...
        uiData.sacDataArray(doneGrp, 6)], ones(nnz(doneGrp), 1), 2), ...
        'Visible', 'On');
end

% if a target location has been completed and is being revisited, make the
% target location indicator empty (rather than filled), and temporarily
% hide the line connecting the target location to the saccade
% endpoint location as well as the saccade endpoint location marker.
if nnz(~doneGrp)
    set(uiData.handles.hTargetLocs(~doneGrp), ...
        {'MarkerFaceColor'}, ...
        mat2cell(ones(sum(~doneGrp),3), ones(sum(~doneGrp),1), 3));
    set(uiData.handles.hTargSacConLines(~doneGrp), ...
        {'Visible'}, ...
        {'Off'});
    set(uiData.handles.hSacEndLocs(~doneGrp), ...
        {'Visible'}, ...
        {'Off'});
end

% reassign data structure to figure handle
set(get(get(uiData.handles.hTargetLocs(1,1), 'Parent'), 'Parent'), ...
    'UserData', uiData);

% not sure why this is necessary but make sure each target location
% indicator has the callback it needs.
set(uiData.handles.hTargetLocs, 'ButtonDownFcn', ...
    {@hTargetLoc_ButtonDownFcn, uiData});

drawnow;
end

function updateHeatMap(uiData)

flatt = @(x)x(:);
repPts  = @(x,y)repmat(x,y,1);
newCData    = [];

% map types list: (1) saccade peak velocity ("pkv"), (2) saccade reaction
% time ("srt"), (3) spike counts ("spk"), but only if ripple is connected:
if isfield(uiData.pldapsData.p.rig, 'ripple') && ...
        uiData.pldapsData.p.rig.ripple.status
    mapTypes    = {'pkv', 'srt', 'spk'};
else
    mapTypes    = {'pkv', 'srt'};
end
nMapTypes   = length(mapTypes);

% if more than 2 trials are complete, make maps
if nnz(uiData.sacDataArray(:, 9)) > 2
    
    % which trials are completed?
    g = logical(uiData.sacDataArray(:, 9));
    
    % if we have enough unique target-location trials, make a map
    if size(unique(uiData.sacDataArray(g, [1 2]), 'rows'), 1) > 2
        
        % make sure we don't get an annoying warning from
        % triscatteredinterp
        warning('off', 'MATLAB:TriScatteredInterp:DupPtsAvValuesWarnId');
        
        % calculate saccade vectors
        X = uiData.sacDataArray(g, 5) - uiData.sacDataArray(g, 3);
        Y = uiData.sacDataArray(g, 6) - uiData.sacDataArray(g, 4);
        
        % how many x / y points define the verticies of our heatmap(s)?
        [nY, nX]    = size(get(uiData.handles.hHeatMap, 'CData'));
        
        % get map x / y points
        mapX = get(uiData.handles.hHeatMap, 'XData');
        mapY = get(uiData.handles.hHeatMap, 'YData');
        
        % "raw" peak velocity (pkv) values
        uiData.heatMaps.pkvCurr.rawVals = uiData.sacDataArray(g, 7);
        
        % "raw" reaction time (srt) values
        uiData.heatMaps.srtCurr.rawVals = uiData.sacDataArray(g, 8);

        % "raw" spike count values. multiple steps here. first we need to
        % get target radius and theta for each trial's spike data, then
        % convert to target X / target Y. Then we need to get the spike
        % counts in the time window specified in the "choose spike map data
        % source" panel. But we only do this if we have spike times to work
        % with:
        if isfield(uiData.pldapsData.p.rig, 'ripple') && ...
                uiData.pldapsData.p.rig.ripple.status
        tRad = double(cellfun(...
            @(x)x(circshift(...
            x == uiData.pldapsData.p.init.codes.targetRadius, 1)), ...
            uiData.spikesAndEvents.eventValues) / 100);
        tTheta = double(cellfun(...
            @(x)x(circshift(...
            x == uiData.pldapsData.p.init.codes.targetTheta, 1)), ...
            uiData.spikesAndEvents.eventValues) / 10);
        tXY = [tRad'.*cosd(tTheta'), tRad'.*sind(tTheta')];
        countWin = [uiData.handles.hSpikeCountWinStart.Value, ...
            uiData.handles.hSpikeCountWinEnd.Value] / 1000;
        rasterInfo = get(uiData.handles.hRasterLine, 'UserData');
        uiData.heatMaps.spkCurr.rawVals = ...
            cellfun(@(x)nnz(x > countWin(1) & x < countWin(2)), ...
            cellfun(@(x,y)x-y, uiData.spikesAndEvents.spikeTimes, ...
            cellfun(@(x,y)y(x == rasterInfo.relTimeCodes(...
            uiData.handles.hSpikeMapType.Value)), ...
            uiData.spikesAndEvents.eventValues, ...
            uiData.spikesAndEvents.eventTimes, ...
            'UniformOutput', false), ...
            'UniformOutput', false))';
        end
        
        % loop over map types and define interpolant funcitons.
        for i = 1:nMapTypes
            % map name / type; append with "curr" to indicate that the map
            % is based on data being collected in the "current" session.
            mapString = [mapTypes{i}, 'Curr'];
            
            % at the moment we have to use a different set of X / Y
            % coordinates for the spikes-based map. FIX THIS! (JPH -
            % 3/2/2023).

            if contains(mapTypes{i}, 'spk')
                % make map function (interpolant).
                uiData.heatMaps.(mapString).F = scatteredInterpolant(...
                    tXY(:,1), tXY(:,2), ...
                    uiData.heatMaps.(mapString).rawVals, ...
                    'linear', 'none');
            else
                % make map function (interpolant).
                uiData.heatMaps.(mapString).F = scatteredInterpolant(...
                    X, Y, ...
                    uiData.heatMaps.(mapString).rawVals, ...
                    'linear', 'none');
            end

            % evaluate map functions at map vertex points
            uiData.heatMaps.(mapString).mapVals = reshape(...
                uiData.heatMaps.(mapString).F(...
                [flatt(repmat(mapX, nY, 1)), repmat(mapY', nX, 1)]...
                ), nY, nX);

            % NEED TO INCLUDE CODE FOR COMPUTING DIFFERENCES IF DESIRED
            
            % calculate colorbar stuff
            [uiData.heatMaps.(mapString).colorBarVals, ...
                uiData.heatMaps.(mapString).colorBarTickVals, ...
                uiData.heatMaps.(mapString).colorBarLim] = ...
                colorBarCalcs(uiData.heatMaps.(mapString).mapVals(:));
        end
        
        % update heatMapSelection listbox with names of available maps
        set(uiData.handles.hHeatMapSelectionList, ...
            'String', fieldnames(uiData.heatMaps));
        
        % update heatMap display
        uiData = updateHeatMapDisplay(uiData);
        
        % store uiData in gui "UserData" field
        set(uiData.handles.hGui, 'UserData', uiData);
        
    end
end

end

function updateSpikePlots(uiData)

% Check to see that there is spike data to plot, and that ripple is
% connected:
if ~isempty(uiData.spikesAndEvents) && ...
        uiData.pldapsData.p.rig.ripple.status

    % We store several bits of information that are useful for plotting
    % rasters in the "UserData" field of hRasterLine. Retreive whatever is
    % in that field now. If it's empty it hasn't yet been defined and we
    % need to define it once here:
    rasterInfo = get(uiData.handles.hRasterLine, 'UserData');
    if isempty(rasterInfo)
        rasterInfo.currRasterCount  = 0;
        rasterInfo.relTimeCodes         = [...
            uiData.pldapsData.p.init.codes.targetOn, ...
            uiData.pldapsData.p.init.codes.fixOff, ...
            uiData.pldapsData.p.init.codes.saccadeOnset];
        rasterInfo.lineRad          = 0.4;
    end

    % check and see if we need to plot a new raster line:
    nTrials = length(uiData.spikesAndEvents.spikeTimes);
    if rasterInfo.currRasterCount < nTrials

        newRasterCount = rasterInfo.currRasterCount + 1;
        rasterInfo.currRasterCount = newRasterCount;
        set(uiData.handles.hRasterLine, 'UserData', rasterInfo);

        % Assign current trial's spike times to a variable to make code
        % more legible, the count them:
        spTimes = uiData.spikesAndEvents.spikeTimes{end}(:);
        nSpikes = length(spTimes);

        % get times of events that we want to align spikes to (target 
        % onset, fixation offset, and saccade onset):
        relTimes = uiData.spikesAndEvents.eventTimes{end}(...
            ismember(uiData.spikesAndEvents.eventValues{end}, ...
            rasterInfo.relTimeCodes));

        % use "copyobj" to duplicate the rasterLine object to the 3 spike
        % plotting axes n times, where n is the number of new spikes:
        newRasters  = copyobj(uiData.handles.hRasterLine, ...
            reshape(...
            repmat(...
            [uiData.handles.hSpikeRasterAxesTargetOnset, ...
            uiData.handles.hSpikeRasterAxesFixOffset, ...
            uiData.handles.hSpikeRasterAxesSaccadeOnset], nSpikes, 1), ...
            [nSpikes * 3, 1]));

        % Set X / Y data for new raster lines:
        set(newRasters, ...
            {'XData'}, mat2cell(repmat(spTimes(:), 3, 2) - ...
            repmat(reshape(...
            repmat(relTimes, nSpikes, 1), [3 * nSpikes, 1]), 1, 2), ...
            ones(1, 3 * nSpikes,1), 2), ...
            {'YData'}, mat2cell(repmat(newRasterCount, 3 * nSpikes,2) + ...
            repmat([-1 1] * rasterInfo.lineRad, 3 * nSpikes, 1), ...
            ones(1, 3 * nSpikes, 1), 2));

        % loop over relTimeCodes to get all spike times across trials 
        % relative to each event we want a spike rate trace aligned to, and
        % compute binned spike counts:
        spCounts    = cell(3, 1);
        binEdges    = cell(3, 1);
        binCenters  = cell(3, 1);
        for i = 1:3
            spikesForBinning = cell2mat(cellfun(@(x,y)x'-y, ...
                uiData.spikesAndEvents.spikeTimes, ...
                cellfun(@(x,y)y(x == rasterInfo.relTimeCodes(i)), ...
                uiData.spikesAndEvents.eventValues, ...
                uiData.spikesAndEvents.eventTimes, ...
                'UniformOutput', false), ...
                'UniformOutput', false)');
            [spCounts{i}, binEdges{i}] = histcounts(...
                spikesForBinning, 'BinWidth', 0.025);
            binCenters{i} = mean([binEdges{i}(1:end-1); ...
                binEdges{i}(2:end)]);
        end

        % convert from binned spike counts to mean spike rate per bin
        % across trials:
        spCounts = cellfun(@(x)x/(rasterInfo.currRasterCount * 0.02), ...
            spCounts, 'UniformOutput', false);

        % update the spike rate traces:
        set([uiData.handles.hSpikeRateTargetOnset; ...
            uiData.handles.hSpikeRateFixOffset; ...
            uiData.handles.hSpikeRateSaccadeOnset], ...
            {'XData'}, binCenters, {'YData'}, spCounts);

        % update the x-limits on the binned-spike plotting axes to match
        % the raster plotting axes:
        set([uiData.handles.hSpikeRateAxesTargetOnset; ...
            uiData.handles.hSpikeRateAxesFixOffset; ...
            uiData.handles.hSpikeRateAxesSaccadeOnset], ...
            {'XLim'}, get([uiData.handles.hSpikeRasterAxesTargetOnset; ...
            uiData.handles.hSpikeRasterAxesFixOffset; ...
            uiData.handles.hSpikeRasterAxesSaccadeOnset], 'XLim'));

        % update the y-limits on the raster plots based on how many trials
        % we're plotting. If we've got 40 or fewer, keep the y-lims at 40,
        % otherwise, update...
        yplotmin = max([40 newRasterCount]);
        set([uiData.handles.hSpikeRasterAxesTargetOnset; ...
            uiData.handles.hSpikeRasterAxesFixOffset; ...
            uiData.handles.hSpikeRasterAxesSaccadeOnset], ...
            {'YLim'}, {[0 yplotmin]}, {'YTick'}, {0:10:yplotmin});

        % Update zero-mark plot objects to span y range:
        set([uiData.handles.hSpikeZeroMarkTargetOnset; ...
            uiData.handles.hSpikeZeroMarkFixOffset; ...
            uiData.handles.hSpikeZeroMarkSaccadeOnset], ...
            {'YData'}, {[0 yplotmin]});
    end
end

drawnow;

% one more change to make: it would be good to plot a line at 0 in all of
% the plots that is updated as the y-limits change.

% After you've done what's above, you can go check out "updateHeatMap" here
% in "saccadeGUI" to figure out how to add a spikes-based heatmap to the
% list of heatmaps, and figure out how to modify that heatmap as new data
% come in.

end

function uiData = makeNewHeatMap(uiData, X, Y, Z, name)

% in line function
flatt = @(x)x(:);

% how many x / y points define the verticies of our heatmap(s)?
[nY, nX]    = size(get(uiData.handles.hHeatMap, 'CData'));

% get map x / y points
mapX = get(uiData.handles.hHeatMap, 'XData');
mapY = get(uiData.handles.hHeatMap, 'YData');

% map name
mapString = name;

% store "raw values"
uiData.heatMaps.(mapString).rawVals = Z;

% make map function (interpolant).
uiData.heatMaps.(mapString).F = TriScatteredInterp(X, Y, ...
    uiData.heatMaps.(mapString).rawVals);

% evaluate map functions at map vertex points
uiData.heatMaps.(mapString).mapVals = reshape(...
    uiData.heatMaps.(mapString).F(...
    [flatt(repmat(mapX, nY, 1)), repmat(mapY', nX, 1)]...
    ), nY, nX);

% calculate colorbar stuff
[uiData.heatMaps.(mapString).colorBarVals, ...
    uiData.heatMaps.(mapString).colorBarTickVals, ...
    uiData.heatMaps.(mapString).colorBarLim] = ...
    colorBarCalcs(uiData.heatMaps.(mapString).mapVals(:));

% update heatMapSelection listbox with names of available maps
set(uiData.handles.hHeatMapSelectionList, ...
    'String', fieldnames(uiData.heatMaps));

end

function uiData = updateHeatMapDisplay(uiData)

% Get list of heatMaps from listbox and numerical index for currently
% selected value
heatMapNames    = get(uiData.handles.hHeatMapSelectionList, 'String');
listBoxVal      = get(uiData.handles.hHeatMapSelectionList, 'Value');

% How many maps are selected in the listbox? If only 1, just display that
% map, if 2, display a difference map.
if length(listBoxVal) > 1
    
    % map names
    mapStrings       = heatMapNames(listBoxVal);
    
    % compute difference of map values
    mapVals = uiData.heatMaps.(mapStrings{1}).mapVals - ...
        uiData.heatMaps.(mapStrings{2}).mapVals;
    
    % calculate color bar and color limit stuff
    [barVals, tickVals, clim] = colorBarCalcs(mapVals(:));
else
    % currently selected map string
    mapString       = heatMapNames{listBoxVal};
    
    % get data needed to update heatmap & colorbar
    mapVals     = uiData.heatMaps.(mapString).mapVals;
    tickVals    = uiData.heatMaps.(mapString).colorBarTickVals;
    clim        = uiData.heatMaps.(mapString).colorBarLim;
    barVals     = uiData.heatMaps.(mapString).colorBarVals;
    
end


% update colorbar
set(uiData.handles.hColorBarAxes, 'YTickLabel', ...
    arrayfun(@(x)sprintf('%0.2f', x), ...
    tickVals, ...
    'UniformOutput', false), ...
    'CLim', clim);
set(uiData.handles.hColorBarIm, ...
    'CData', barVals);

% update heatmap
set(uiData.handles.hHeatMap, 'CData', ...
    mapVals / ...
    range(mapVals(:)));
set(uiData.handles.hPlotAxes, 'CLim', ...
    clim);

drawnow;

end

function [barVals, tickVals, clim] = colorBarCalcs(Z)

amin = nanmin(Z);
amax = nanmax(Z);
cmin = sign(amin)* abs(amin)/range(Z);
cmax = sign(amax)* abs(amax)/range(Z);
if all([cmin cmax] == 0) || all(isnan([cmin cmax]));
    cmin = 0;
    cmax = 1;
    amin = 0;
    amax = 1;
end
barVals = repmat(linspace(cmin, cmax, 100)',1,2);
tickVals = linspace(amin, amax, 11)';
clim = [cmin, cmax];

end